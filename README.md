# Advent-of-FPGA-2025
# Day1
For Day 1, my initial approach began with the idea that each rotation command has three states: the character that decides the direction, the decimal value used to either add or subtract from a total sum, and then the new line comment, which indicates that another command is coming. To begin, I created the parser by taking in a large string as input. Then, split the string by each of its new lines into a string list using the split_lines operator. Now, with a list of strings, we need to iterate over the list and split the string into two pieces of data, being the character value and the number value. I chose to have the input data separated on the CPU and then sent to the FPGA in 8-bit streams because I am using a MAX10 that only has UART communication, and I thought tasks like parsing a massive string would be much easier for a CPU to do than an FPGA. For the input output structures, I thought I needed a clear, clock, data and valid pin to allow for UART communication. Obviously, no state changes when valid is not high, and this is only important when using the UART. For part 1 structure, I began with the state machine structure. We needed an idle state where nothing happened, and then two states for the different pieces of data being received, these being the character and number. From here, it was an extremely simple approach where in the “Eval” state, you are toggling the direction to either be positive for R and negative for L. This is also in the Idle state because the initiating data signal is an L or R input. For this, I simply made a register that toggles 0 or 1 to decide if, in the AddSum state, you should add or subtract the number input. After running through an iteration where in Eval or Idle State, the dir register is assigned a 0 or 1, then the total sum is added to by the newest number input before checking if this value is equal to 0. If the total sum is equal to zero, then increment the total count counter. The final value is the total count. For handling overflows, the approach I took was just to check if the total sum is greater than 100 first, then to check its direction. This is because the total sum is an 8-bit unsigned, so numbers decremented below zero and incremented above 100 will both be values greater than 100. Then you just have to check the direction used in the previous operation to decide if you must add or subtract 100 from the current total sum. Now, with part 2, we are not just checking if the value is at 0,  but also if there if it rotates over zero. This creates three scenarios where the counter should be incremented, being if the sum is greater than 100, because the dial must have rolled over zero, if the dial is at zero, and if there is a command where you should do more than 100 rotations. So the first statement I added was if the total sum is greater than 100, add one. This simply means if it rotates over or under 100, then increment by one because it has passed zero. Doing this keeps things simple, but creates a logical error when the dial is at exactly zero, and the next operation is a rotate ‘L’ operation, because we have already incremented the value for going over 0, so when it overflows, it will trigger another increment, which is incorrect. The way I handled this edge case was simply by adding the statement that when the direction is ‘L’ and the total sum is exactly zero, decrement the value by 1 to cancel the increment it will get for overflowing. Lastly, the way I decided to handle the case where the number in an instruction is greater than 100 was by letting the CPU handle this task. I did this because I thought the division operation is much easier to do in a CPU than an FPGA, and I can parse the mod value and the integer division with 100, so I can keep almost the exact same state machine as part one and just add a state where the count is incremented by whatever numVal/100 was.

I used the hardcaml demo project template.
